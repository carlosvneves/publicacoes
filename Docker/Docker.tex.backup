\documentclass[a4paper,11pt]{article}

%-----------------------------------------------------------------------------
% Pacotes Necessários
%-----------------------------------------------------------------------------

\usepackage[english]{babel} % padronizar a linguagem
\usepackage[utf8]{inputenc} % permitir a acentuação
\usepackage[protrusion=true,expansion=true]{microtype} % obter melhor tipografia
\usepackage[svgnames]{xcolor} % habitar cores para 'svgnames'
\usepackage[hang, small,labelfont=bf,up,textfont=it,up]{caption} % customizar captions acima/abaixo de tabelas ou figuras
\usepackage{color}    % definir cores
\usepackage{graphicx} % adicionar imagens
\usepackage{fix-cm}   % customizar o tamanho das fontes
\usepackage{sectsty}  % habilitar a customização dos títulos das seções
\usepackage{fancyhdr} % definir cabeçalhos e rodapés
\usepackage{listings} % listagens
\usepackage[ddmmyyyy]{datetime} % mostrar a data
\usepackage{lipsum} % gerar um texto randomico (será tirado ao final)
\usepackage{titling} % Permite a configuração do título
\usepackage{url} % codigo para as URLs
\usepackage[a4paper, inner=1.5cm, outer=3cm, top=2cm, bottom=3cm, 
bindingoffset=1cm]{geometry}
%-----------------------------------------------------------------------------
% Definições Iniciais
%-----------------------------------------------------------------------------

% modificar toda a fonte de todas as seções
\allsectionsfont{\usefont{OT1}{phv}{b}{n}}
% habilitar a customização de cabeçalhos e rodapés
\pagestyle{fancy} 

\addto\captionsenglish{ % modificar os nomes do ingles
  \renewcommand{\abstractname}{Resumo}
  \renewcommand{\bibname}{Consulte também...}
  \renewcommand{\contentsname}{Sumário}
  \renewcommand{\listfigurename}{Figuras}
  \renewcommand{\lstlistingname}{Listagem}
  \renewcommand{\lstlistlistingname}{Listagens}
  \renewcommand{\refname}{Referências}
}

\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

% Definição para as caixas de listagens
\lstset {
 aboveskip=3mm,
 backgroundcolor=\color{backcolour},
 basicstyle={\small\ttfamily},
 belowskip=3mm,
 breaklines=true,
 breakatwhitespace=true,
 columns=flexible,
 commentstyle=\textit,
 frame=tb,
 keepspaces=true,
 keywordstyle=\color{blue}\bfseries,
 % language=Java, Python, HTML, CSS
 numbers=left,
 numbersep=5pt,
 numberstyle=\tiny\color{codegray},
 showstringspaces=false,
 showtabs=false,
 tabsize=3
}

% Cabeçalhos - limpar tudo
\lhead{}
\chead{}
\rhead{}

% Rodapés
\lfoot{\tiny Docker}
\cfoot{\tiny Versão 1.0}
\rfoot{\tiny Folha \thepage\ }

\renewcommand{\headrulewidth}{0.0pt} % No header rule
\renewcommand{\footrulewidth}{0.4pt} % Thin footer rule

\usepackage{lettrine} % Package to accentuate the first letter of the text
\newcommand{\initial}[1]{ % Defines the command and style for the first letter
  \lettrine[lines=3,lhang=0.3,nindent=0em]{
    \color{DarkGoldenrod}
    {\textsf{#1}}
  }{}
}

%-----------------------------------------------------------------------------
% TÍTULO DO DOCUMENTO
%-----------------------------------------------------------------------------

% comando para as barras
\newcommand{\HorRule}{\color{DarkGoldenrod} \rule{\linewidth}{1pt}} 

% barra horizontal superior
\pretitle{\vspace{-90pt} \begin{flushleft} \HorRule \fontsize{50}{50} 
\usefont{OT1}{phv}{b}{n} \color{DarkRed} \selectfont}

% título do documento
\title{Docker}
\posttitle{\par\end{flushleft}\vskip 0.1em} % espaço abaixo do título

% autor do documento
\preauthor{\begin{flushleft}\large \lineskip 0.1em \usefont{OT1}{phv}{b}{sl} 
\color{DarkRed}} % fonte do autor
\author{Fernando Anselmo}
\postauthor{\footnotesize \usefont{OT1}{phv}{m}{sl} \color{Black} \\
 \url{http://fernandoanselmo.orgfree.com/wordpress/} % endereço

\par\end{flushleft}\HorRule} % barra horizontal inferior

\date{Versão 1.0 em \today} % mostrar a data do artigo 

%-----------------------------------------------------------------------------
% INÍCIO DO DOCUMENTO
%-----------------------------------------------------------------------------

\begin{document}
\maketitle % mostrar o título
\thispagestyle{fancy} % habilitar o cabeçalho/rodapé das páginas

%-----------------------------------------------------------------------------
% RESUMO DO ARTIGO
%-----------------------------------------------------------------------------

\begin{abstract}
  % O primeiro caractere deve vir com \initial{}
\initial{D}\textbf{ocker\cite{dockeroficial} veio para revolucionar a forma 
como é abordado o desenvolvimento e a implantação de aplicativos, de modo bem 
simples, é uma plataforma para construir e manter ambientes para a excecução de 
sistemas distribuídos. Um projeto de código aberto que permite a criação de 
contêineres, a partir de imagens, leves e portáteis para diversas aplicações. 
Sua funcionalidade simplifica o uso dos LXC (LinuX Containers), que, 
basicamente, são uma forma de isolamento de processo e sistemas (quase como uma 
virtualização), porém mais integrada ao Sistema Operacional. Os contêineres 
isolam o SO Base (host) e toda pilha de dependências da aplicação 
(bibliotecas, servidores, entre outros) com ganhos de performance.}
\end{abstract}
\vspace{20pt}

%-----------------------------------------------------------------------------
% CONTEÚDO DO ARTIGO
%-----------------------------------------------------------------------------
\section{Parte inicial}
Provavelmente já ouviu falar sobre o Docker, quase todos os dias surgem 
notícias, por meio de inclusões nas redes sociais, notícias em blogs ou eventos 
promovidos por diversas empresas do segmento de tecnologia. Possibilita o 
empacotamento de uma aplicação ou ambiente inteiro dentro de um contêiner, e a 
partir desse momento, torna-se portável para qualquer outro sistema que 
contenha o Docker instalado.
\begin{center} 
\includegraphics[width=0.8\textwidth]{DockerLogo.jpg} 
\end{center}
O Docker nasceu na empresa dotCloud. A empresa dotCloud, na época, era um 
empresa de hospedagem que utilizava LXC em quase todo seu ambiente. O Docker 
trabalha com um sistema de arquivos ``empilháveis'', denominado aufs, 
isso permite que a configuração do contêiner funcione de forma incremental, mais 
ou menos como os ``commits'' do GIT. Docker é uma ferramenta que cria 
rapidamente ambientes isolados para desenvolver e implantar aplicativos. 
Trata-se de uma solução para profissionais de sistema desenvolverem, embarcarem, 
integrarem e executarem suas aplicações rapidamente. \\[3mm]
Seu principal objetivo e proporcionar múltiplos ambientes isolados dentro do 
mesmo servidor, mas acessíveis externamente via tradução de portas. O conceito 
nada mais é do que isolar os recursos e as aplicações através de uma imagem 
(template), otimizando deploy, performance, agilidade, entrega e principalmente 
a forma de como é possível compartilhar todos os recursos sejam físicos ou 
lógicos. \\[3mm]
O Docker oferece um conjunto completo de ferramentas para o transporte de tudo o 
que constitui uma aplicação, seja sistemas ou máquinas (virtual ou física). 
Outra característica do Docker é a permissão para executar em qualquer sistema 
operacional baseado em linux dentro de um contêiner com maior flexibilidade.

\subsection{O que é um Contêiner?}
Docker usa o termo ``Contêiner'' para representar um ambiente em execução e que 
pode executar quase qualquer software; Seja este uma aplicação Web ou um 
serviço. O contêiner é tratado como o artefato, ou seja, o ambiente pode ser 
versionado e distribuído da mesma forma como é realizado com o código fonte de 
uma aplicação. \\[3mm]
LXC é um tipo de virtualização, em nível de sistema operacional, que 
proporciona a execução de múltiplas instâncias isoladas de um determinado 
SO dentro de um único host. O conceito é simples e antigo, sendo que o comando 
``chroot'' seu precursor mais famoso. Com o chroot é possível segregar os 
acessos de diretórios e evitar que o usuário tenha acesso à estrutura raiz (“/” 
ou root). \\[3mm]
Características dos contêineres:
\begin{itemize}
  \item Definir recursos como memória, rede, sistema operacional, 
aplicação ou serviço. 
  \item Realizar testes, desenvolvimento e estudos.
  \item Utilizar em ambiente de produção.
  \item Controlar os recursos como CPU, memória e HD através dos parâmetros 
de configuração, que são passados ao iniciar um contêiner, ou durante sua 
execução.
\end{itemize}
O contêiner é construído usando namepspaces, cgroups, chroot entre outras 
funcionalidades do kernel para construir uma área isolada para a aplicação. 
\\[3mm]
Os contêineres podem ser utilizados através de seguintes redes:
\begin{itemize}
  \item \textbf{Bridge}. Cada contêiner iniciado no docker é associado a uma 
rede especifica, e essa é a rede padrão para qualquer contêiner que não foi 
explicitamente especificado.
  \item \textbf{None}. Isola o contêiner para comunicações externas, ou seja, 
não receberá nenhuma interface para comunicação externa. A sua única interface 
de rede IP será a localhost.
  \item \textbf{Host}. Entrega para o contêiner todas as interfaces existentes 
no docker host. De certa forma isso agiliza a entrega dos pacotes.
\end{itemize}

\subsection{Imagens}
As imagens são como ``blocos de construção'' que agem como ponto de partida 
para os contêineres. As imagens se tornam recipientes e os contêineres podem 
ser transformados em novas imagens otimizadas. Normalmente são imagens do 
host (como o Ubuntu), mas que podem ser altamente personalizadas para conter um 
SO básico (como o Alpine) juntamente com qualquer dependência que é instalada 
nela. Geralmente faz uso do UFS (Sistema de Arquivos Unix), e pode ser criada 
através do arquivo de configuração denominado ``Dockerfile''. \\[3mm]
Um contêiner não pode ser iniciado sem uma imagem. Através de uma imagem 
iniciada por um contêiner é possível gerar novas imagens, basta aplicar um 
“commit“ a cada mudança realizada. \\[3mm]
Resumidamente:
\begin{itemize}
  \item \textbf{Imagem}: é uma template que define a estrutura para os 
contêineres.
  \item \textbf{Contêiner}: simula o ambiente de execução como um todo, é uma 
``instância'' da imagem.
\end{itemize}

\section{Instalação do Docker no Ubuntu 16.10}
A instalação do Docker pode ser realizada no ambiente Ubuntu versão 16.10 
através de duas formas (ambas através do acesso ao terminal):
\begin{itemize}
\item \textbf{Via comandos}: Um modo mais ``seguro'' pois estará vendo (e 
controlando) o que está sendo executado.
\item \textbf{Via script}: Um modo mais ``simples'' pois com poucos comandos 
todo o ambiente é instalado.
\end{itemize}

\subsection{Modo 1: Via comandos}
Nesta seção será instalado e configurado o Docker no sistema operacional Ubuntu 
16.10. Como passo inicial é necessário instalar e levantar o servidor:
\begin{enumerate}
  \item Desinstalar o LXC: {\ttfamily\$ sudo apt purge lxc-docker}
  \item Instalar a base de certificados HTTPS: {\ttfamily\$ sudo apt install 
apt-transport-https ca-certificates}
  \item Adicionar a chave: {\ttfamily\$ sudo apt-key adv --keyserver \\ 
\url{hkp://p80.pool.sks-keyservers.net:80} --recv-keys \\ 
58118E89F3A912897C070ADBF76221572C52609D}
  \item Adicionar o sistema: {\ttfamily\$ echo "deb \\ 
\url{https://apt.dockerproject.org/repo} ubuntu-yakkety main" | sudo tee \\ 
\url{/etc/apt/sources.list.d/docker.list}}
  \item Atualizar o sistema: {\ttfamily\$ sudo apt-get update}
  \item Instalar: {\ttfamily\$ sudo apt install docker docker.io}
  \item Adicionar seu usuário ao grupo docker: {\ttfamily\$ sudo usermod -aG 
docker [seu usuário]}
  \item Reiniciar o computador: {\ttfamily\$ sudo reboot}
  \item Parar o servidor: {\ttfamily\$ sudo service docker stop}
  \item Levantar o servidor: {\ttfamily\$ sudo service docker start}
  \item Verificar se tudo está bem: {\ttfamily\$ sudo service docker status}
  \item Verificar a versão: {\ttfamily\$ docker -v}
\end{enumerate}

\subsection{Modo 2: Via script}
Outra forma de instalar o Docker, é através da execução de um script que está 
disponibilizado em seu site oficial no endereço \url{https://get.docker.com}, 
digitar os seguintes comandos: \\[1mm]
{\ttfamily\$ sudo su} \\[1mm]
{\ttfamily\# wget -qO- \url{https://get.docker.com} | sh} \\[3mm]
Ao término é necessário adicionar o seu usuário ao grupo docker através do 
comando: \\[1mm]
{\ttfamily\# usermod -aG docker [seu usuário]}

\subsection{Testar a instalação com um Hello World}
Com um simples comando é possível testar todo o ambiente: \\[1mm]
{\ttfamily\$ docker run hello-world} \\[3mm]
Se tudo estiver funcionando corretamente uma imagem será baixada, um contêiner 
criado e executado e mostrará a seguinte mensagem:
\begin{center} 
\includegraphics[width=0.8\textwidth]{hello.png} 
\end{center}

\section{Utilização do Docker}
Antes de começar a utilizar o Docker é recomendável proceder um registro 
(gratuito) em seu repositório oficial de imagens. Acessar 
\url{https://hub.docker.com/} e proceder o registro.

\subsection{Guia com os comandos básicos}
Nos comandos a seguir, o termo [imagem] se refere ao nome ou ID da imagem, 
assim como o termo [contêiner] se refere ao nome ou ID do contêiner. Obter 
informações sobre o Docker instalado: \\[1mm]
{\ttfamily\$ docker info} \\[3mm]
Sobre a versão do Docker instalado: \\[1mm]
{\ttfamily\$ docker version} \\[3mm]
Verificar a existência de imagens: \\[1mm]
{\ttfamily\$ docker images} \\[3mm]
Procurar uma imagem: \\[1mm]
{\ttfamily\$ docker search [imagem]} \\[3mm]
Baixar uma imagem: \\[1mm]
{\ttfamily\$ docker pull [imagem]} \\[3mm]
Construir uma imagem: \\[1mm]
{\ttfamily\$ docker build -t [imagem] [caminho para dockerfile]} \\[3mm]
Subir uma imagem: \\[1mm]
{\ttfamily\$ docker push [imagem]} \\[3mm]
Executar uma imagem: \\[1mm]
{\ttfamily\$ docker run [imagem]:[tag]} \\[3mm]
Executar uma imagem desviando uma porta específica: \\[1mm]
{\ttfamily\$ docker run -d -p \url{[porta host]:[porta contêiner]} --name 
[contêiner] [imagem]} \\[3mm]
Iniciar um contêiner: \\[1mm]
{\ttfamily\$ docker start [contêiner]} \\[3mm]
Executar comando no contêiner: \\[1mm]
{\ttfamily\$ docker exec [contêiner] [comando]} \\[3mm]
Iniciar uma sessão bash em um contêiner que esteja rodando: \\[1mm]
{\ttfamily\$ docker exec -it [contêiner] bash} \\[3mm]
Listar todos os contêineres: \\[1mm]
{\ttfamily\$ docker ps -a} \\[3mm]
Ver os logs de um contêiner: \\[1mm]
{\ttfamily\$ docker logs [contêiner]} \\[3mm]
Parar um contêiner: \\[1mm]
{\ttfamily\$ docker stop [contêiner]} \\[3mm]
Remover um contêiner:  \\[1mm]
{\ttfamily\$ docker rm -f [contêiner]} \\[3mm]
Remover TODOS os contêineres \\[1mm]
{\ttfamily\$ docker rm -f \$(docker ps -a -q)} \\[3mm]
Remover uma imagem: \\[1mm]
{\ttfamily\$ docker rmi -f [imagem]}

\subsection{Sair e retornar ao contêiner}
Por muitas vezes os contêineres são criados como ambientes (bash) no qual se 
pode executar comandos, mas pode ser necessário retornar ao host. No contêiner 
realizar a seguinte sequencia: {\ttfamily Ctrl+P+Q}. Para retornar ao ambiente 
do contêiner, utilizar o comando: \\[1mm]
{\ttfamily\$ docker attach [imagem]} \\[3mm]
Para sair de vez do ambiente do contêiner, realizar a seguinte sequencia: 
{\ttfamily Ctrl+D} ou com o comando {\ttfamily exit}.

\subsection{Baixar a imagem oficial do Mongo}
Uma das grandes vantagens do Docker é o poder de instalar um software sem a 
preocupação de suas dependências, ou, no momento de sua desinstalação não deixar 
quaisquer resquícios de bibliotecas perdidas. \\[3mm]
Baixar a imagem oficial do Mongo: \\[1mm]
{\ttfamily\$ docker pull mongo} \\[3mm]
Criar um contêiner: \\[1mm]
{\ttfamily\$ docker run --name some-mongo -p 27017:27017 -d mongo} \\[3mm]
Acessar o administrador do Mongo: \\[1mm]
{\ttfamily\$ docker exec -it some-mongo mongo admin}

\subsection{Criar uma imagem}
Dockerfile é um arquivo em formato texto que contém todos os comandos 
necessários para montar uma imagem Docker. Também é possível obter o Dockerfile 
de uma determinada imagem, modificar o que deseja e criar uma nova imagem. Isso 
pode demorar um pouco mais, mas essa imagem será muito mais ``enxuta'' e 
obtem-se o total controle do seu estado, o que seria bem mais difícil no modelo 
de efetuar ``commit'' de um contêiner. \\[3mm]
Seus comandos principais são:
\begin{itemize}
\item \textbf{FROM}. Imagem base, é usada com nome da distribuição (Debian, 
Ubuntu), para não ocorrer a necessidade em se criar toda estrutura.
\item \textbf{LABEL}. São rótulos para ajudar na organização das imagens por 
projeto, registrar informações de licenciamento, auxiliar na automação ou por 
quaisquer outros motivos.
\item \textbf{MAINTAINER}. Especifica o autor da imagem.
\item \textbf{RUN}. Instruções que serão executadas para criação da imagem.
\item \textbf{ENV}. Para atualizar uma variável de ambiente PATH para o 
software que o contêiner instala. É útil para fornecer variáveis de ambiente 
necessárias especificadas para os serviços.
\item \textbf{ADD e COPY}. Embora sejam funcionalmente semelhantes, de um modo 
geral, a COPY é preferida. Isso é porque é mais transparente do que ADD. 
COPY suporta a cópia básica de arquivos locais no contêiner, enquanto ADD tem 
alguns recursos (como a extração de tar local-only e o suporte de 
URL remoto) que não são imediatamente óbvios. Consequentemente, o melhor uso 
para ADD é a auto-extração local do arquivo do tar na imagem.
\item \textbf{CMD}. Deve ser usada para executar um software contido pela 
imagem, juntamente com quaisquer argumentos.
\item \textbf{ENTRYPOINT}. Especifica o que será executado ao 
iniciar o contêiner. Age como precedente à sintaxe CMD, ou seja, caso o 
ENTRYPOINT seja ``top'', o CMD pode ser ``-b'', que nesse caso executa o top em 
modo batch. Uma vez que o ENTRYPOINT não seja especificado, e um CMD seja 
usado, o ENTRYPOINT padrão é ``/bin/sh -c''. 
\item \textbf{EXPOSE}. Usado para informar qual porta o contêiner docker 
escuta, essa informação é utilizada para interconexão entre contêineres, ao 
utilizar links. EXPOSE não define qual porta será exposta para o hospedeiro ou 
tornar possível o acesso externo para portas do contêiner em questão. Para 
expor essas portas, utiliza-se em tempo de inicialização da imagem a flag ``-p'' 
ou ``-P''.
\end{itemize}
Por exemplo, esses são os passos necessários para se criar uma imagem para o 
banco MongoDB. 
\\[3mm]
1º) Criar uma pasta para abrigar o arquivo: \\[1mm]
{\ttfamily\$ mkdir mongod} \\[3mm]
2º) Entrar na pasta: \\[1mm]
{\ttfamily\$ cd mongod} \\[3mm]
3º) Criar um arquivo chamado \textbf{Dockerfile} com o seguinte conteúdo:
\begin{lstlisting}
FROM ubuntu:yakkety
MAINTAINER Fernando Anselmo <fernando.anselmo74@gmail.com>

# Adiciona o usuário e o grupo
RUN groupadd -r mongodb && useradd -r -g mongodb mongodb

RUN apt-get update \
  && apt-get install -y --no-install-recommends \
    numactl \
  && rm -rf /var/lib/apt/lists/*

# Adiciona o grab gosu
ENV GOSU_VERSION 1.7
RUN set -x \
  && apt-get update && apt-get install -y --no-install-recommends ca-certificates wget && rm -rf /var/lib/apt/lists/* \
  && wget -O /usr/local/bin/gosu "https://github.com/tianon/gosu/releases/download/$GOSU_VERSION/gosu-$(dpkg --print-architecture)" \
  && wget -O /usr/local/bin/gosu.asc "https://github.com/tianon/gosu/releases/download/$GOSU_VERSION/gosu-$(dpkg --print-architecture).asc" \
  && export GNUPGHOME="$(mktemp -d)" \
  && gpg --keyserver ha.pool.sks-keyservers.net --recv-keys B42F6819007F00F88E364FD4036A9C25BF357DD4 \
  && gpg --batch --verify /usr/local/bin/gosu.asc /usr/local/bin/gosu \
  && rm -r "$GNUPGHOME" /usr/local/bin/gosu.asc \
  && chmod +x /usr/local/bin/gosu \
  && gosu nobody true \
  && apt-get purge -y --auto-remove ca-certificates wget

# Importar a chave
RUN apt-key adv --keyserver ha.pool.sks-keyservers.net --recv-keys 492EAFE8CD016A07919F1D2B9ECBEC467F0CEB10

ENV MONGO_MAJOR 3.0
ENV MONGO_VERSION 3.0.14
ENV MONGO_PACKAGE mongodb-org

RUN echo "deb http://repo.mongodb.org/apt/debian wheezy/mongodb-org/$MONGO_MAJOR main" > /etc/apt/sources.list.d/mongodb-org.list

RUN set -x \
  && apt-get update \
  && apt-get install -y \
    ${MONGO_PACKAGE}=$MONGO_VERSION \
    ${MONGO_PACKAGE}-server=$MONGO_VERSION \
    ${MONGO_PACKAGE}-shell=$MONGO_VERSION \
    ${MONGO_PACKAGE}-mongos=$MONGO_VERSION \
    ${MONGO_PACKAGE}-tools=$MONGO_VERSION \
  && rm -rf /var/lib/apt/lists/* \
  && rm -rf /var/lib/mongodb \
  && mv /etc/mongod.conf /etc/mongod.conf.orig

RUN mkdir -p /data/db /data/configdb \
  && chown -R mongodb:mongodb /data/db /data/configdb
VOLUME /data/db /data/configdb

COPY docker-entrypoint.sh /entrypoint.sh
ENTRYPOINT ["/entrypoint.sh"]

EXPOSE 27017
CMD ["mongod"]
\end{lstlisting}
4º) Criar a imagem: \\[1mm]
{\ttfamily\$ docker build -t mongod .} \\[3mm]
Veja mais referencias sobre essas construções\cite{constimagem}.

\subsection{Trabalhar com o Alpine}
Alpine é uma distribuição construída com musl libc e BusyBox, que é conhecida 
como canivete suíço, pois combina versões minúsculas de muitos utilitários 
comuns no UNIX em um único pequeno executável. \\[3mm]
Algumas características do Alpine:
\begin{enumerate}
  \item Enquanto a menor imagem para Docker precisa de cerca de 130 Mb de 
espaço em disco, a Alpine precisa de no máximo 8 Mb, isso faz com que, mesmo 
montando todo o seu ambiente, nunca terá o mesmo tamanho do que se montando em 
um imagem tradicional, isso é ótimo, pois deixa o ambiente ainda mais enxuto e 
simples de migrar.
  \item Possui apenas o que é necessário para o funcionamento da aplicação, se 
precisar de mais alguma biblioteca, deve ser instalada, não é necessário se 
preocupar em desativar ou remover lixos, eles simplesmente não existem.
  \item Foi desenvolvida pensando em segurança, e para garantir isso os 
desenvolvedores se preocuparam aprimorar os recursos de segurança do kernel como 
grsecurity/PaX, além disso, todos os binários foram compilados em 
executáveis independente de posição, isso previne alguns uso problemas 
  relacionados a buffer overflow e outros tipos de ataques envolvendo estouro 
de pilha.
\end{enumerate}
Na prática, criar um arquivo chamado \textbf{app.js} com o seguinte conteúdo:
\begin{lstlisting}
var http = require('http');
http.createServer(function(req,res) {
 res.writeHead(200, { 'Content-Type': 'text/plain; charset=utf-8' });
 res.end('Node.js no Docker com Alpine');
}).listen(8080);
\end{lstlisting}
Criar um arquivo chamado \textbf{package.json} com o seguinte conteúdo:
\begin{lstlisting}
{
"name": "docker_web_app",
"version": "1.0.0",
"description": "Node.js on Docker",
"author": "First Last <first.last@example.com>",
"main": "app.js"
}
\end{lstlisting}
Criar um arquivo chamado \textbf{Dockerfile} com o seguinte conteúdo:
\begin{lstlisting}
FROM alpine:3.1
# Update
RUN apk add --update nodejs
# Cria a pasta da app
RUN mkdir -p /usr/src/app
WORKDIR /usr/src/app
# Instala as dependencias da app
COPY package.json /usr/src/app/
RUN npm install
# copia a app
COPY . /usr/src/app
EXPOSE 8080
CMD ["node", "/usr/src/app/app.js"]
\end{lstlisting}
Para criar a imagem: \\[1mm]
{\ttfamily\$ docker build -t alpteste .} \\[3mm]
Para executar a imagem: \\[1mm]
{\ttfamily\$ docker run -p 8080:8080 -d alpteste} \\[3mm]
Verificar o contêiner em execução: \\[1mm]
{\ttfamily\$ docker ps} \\[3mm]
Ao abrir um navegador no seguinte endereço: \url{http://localhost:8080}, e será 
mostrada a seguinte mensagem: {\ttfamily Node.js no Docker com Alpine}. \\[3mm]
E para interromper o contêiner: \\[1mm]
{\ttfamily\$ docker stop [id do contêiner]} \\[3mm]
A imagem oficial do Node.js pode ser obtida em: 
\url{https://hub.docker.com/_/node/}.

\subsection{Propriedade Volume}
Volume é um diretório dentro de um contêiner associado a outro que existe 
fora, ou seja, é um mapeamento para um diretório existente na máquina host ou 
no dispositivo NFS remoto. O diretório que um volume mapeia existe independente 
de qualquer contêiner que o monte. Isso significa que se pode criar 
contêineres, gravar em volumes e, em seguida, destruí-los sem perder dados de 
aplicativos. \\[3mm]
Os volumes são excelentes para compartilhar dados (ou estado) entre contêineres, 
montando o mesmo volume em vários contêineres. É a maneira mais adequada para 
editar os fontes de uma aplicação dentro de um contêiner. \\[3mm]
Primeiro detalhe a realizar é verificar qual local que o contêiner usa para ler 
os códigos que se deseja manipular. Por exemplo, a pasta do Apache 
\url{/var/www/}. Caso o código local esteja na pasta \url{/home/usuario/codigo}, 
o comando docker para fazer o mapeamento é o seguinte: \\[1mm]
{\ttfamily\$ docker -d -v \url{/home/usuario/codigo}:\url{/var/www} imagem} 
\\[3mm]
Deste modo, tudo que for adicionado ou modificado na pasta 
\url{/home/usuario/codigo} do host docker, será modificado na pasta 
\url{/var/www} dentro do contêiner. \\[3mm]
\textbf{Importante}: alguns serviços específicos precisam que o serviço seja 
reiniciado em caso de mudança no código, nesse caso, basta parar o contêiner e 
reiniciar novamente.

\subsection{Configurar o PID}
Por padrão todos os contêineres possuem o PID namespace habilitado. O Namespace 
PID remove o ponto de vista dos processos do sistema e permite identificadores 
(ID) de processos para serem utilizados. Em alguns casos deve-se executar 
alguma ferramenta de depuração no contêiner para que consiga visualizar os 
processos do host, então basta iniciar o contêiner com a opção de PID ativado: 
\\[1mm]
{\ttfamily\$ docker run -it --rm --pid=host imagem} \\[3mm]
É possível também utilizar o PID para depurar as informações de outro 
contêiner, para isso deve-se iniciar a execução de um contêiner 
com MongoDB e depois um contêiner para realizar a depuração: \\[1mm]
{\ttfamily\$ docker run --name mongo -d mongodb} \\[1mm]
{\ttfamily\$ docker run --it \\ --pid=[contêiner]:mongo [imagem]}

\section{Conclusão}
O Docker também estabelece um padrão de empacotamento de soluções. Ou seja, uma 
vez criada a estrutura do ambiente ela pode ser facilmente replicada, usada 
comoreferência para a criação de novas estruturas. O Docker fornece os blocos 
construtivos fundamentais necessários às implantações de contêineres 
distribuídos através da filosofia PODA (Package Once Deploy Anywhere). \\[3mm]
Foi citado nesta o que é o Docker e o que é possível fazer, porém não se deve 
utilizá-lo para tratar o contêiner como uma máquina virtual. É apenas um 
serviço, nada mais que um processo do Host hospedeiro. O contêiner não pode ter 
uma vida longa (uptime), como ele é um processo do host hospedeiro, ele precisa 
ser encerrado e iniciado quando possível. Não armazene dados dentro do 
contêiner, utilize sempre o parâmetro volumes para armazenar os dados dinâmicos. 
E por fim, assegure que o host hospedeiro possui os recursos necessários de 
segurança para acesso nos contêineres. \\[3mm]
Através do empacotamento dos componentes, das aplicações em seus próprios 
contêineres e da sua escalabilidade horizontal torna-se um simples processo de 
lançar ou desligar múltiplas instâncias de cada componente. Sou um entusiasta do 
mundo Open Source e novas tecnologias. Veja outros artigos que publico sobre 
tecnologia acessando meu Blog Oficial \cite{fernandoanselmo}.

%-----------------------------------------------------------------------------
% REFERÊNCIAS
%-----------------------------------------------------------------------------

\begin{thebibliography}{3}

  \bibitem{dockeroficial} 
  Página do Docker \\
  \url{https://www.docker.com/}
  
  \bibitem{constimagem} 
  Construção de Imagens \\
  \url{https://docs.docker.com/engine/reference/builder/}

  \bibitem{fernandoanselmo} 
  Fernando Anselmo - Blog Oficial de Tecnologia \\
  \url{http://www.fernandoanselmo.blogspot.com.br/}

\end{thebibliography}
  
\end{document}
